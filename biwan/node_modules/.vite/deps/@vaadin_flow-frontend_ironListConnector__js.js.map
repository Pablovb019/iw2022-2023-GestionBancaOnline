{
  "version": 3,
  "sources": ["../../@vaadin/flow-frontend/ironListConnector.js"],
  "sourcesContent": ["import { Debouncer } from '@polymer/polymer/lib/utils/debounce.js';\r\nimport { timeOut } from '@polymer/polymer/lib/utils/async.js';\r\n\r\nwindow.Vaadin.Flow.ironListConnector = {\r\n  initLazy: function (list) {\r\n    // Check whether the connector was already initialized for the Iron list\r\n    if (list.$connector) {\r\n      return;\r\n    }\r\n\r\n    const extraItemsBuffer = 20;\r\n\r\n    let lastRequestedRange = [0, 0];\r\n\r\n    list.$connector = {};\r\n    list.$connector.placeholderItem = { __placeholder: true };\r\n\r\n    const updateRequestedItem = function () {\r\n      /*\r\n       * TODO Iron list seems to do a small index adjustment after scrolling\r\n       * has stopped. This causes a redundant request to be sent to make a\r\n       * corresponding minimal change to the buffer. We should avoid these\r\n       * requests by making the logic skip doing a request if the available\r\n       * buffer is within some tolerance compared to the requested buffer.\r\n       */\r\n      let firstNeededItem = list._virtualStart;\r\n      let lastNeededItem = list._virtualEnd;\r\n\r\n      let first = Math.max(0, firstNeededItem - extraItemsBuffer);\r\n      let last = Math.min(lastNeededItem + extraItemsBuffer, list.items.length);\r\n\r\n      if (lastRequestedRange[0] != first || lastRequestedRange[1] != last) {\r\n        lastRequestedRange = [first, last];\r\n        const count = 1 + last - first;\r\n        list.$server.setRequestedRange(first, count);\r\n      }\r\n    };\r\n\r\n    let requestDebounce;\r\n    const scheduleUpdateRequest = function () {\r\n      requestDebounce = Debouncer.debounce(requestDebounce, timeOut.after(10), updateRequestedItem);\r\n    };\r\n\r\n    /*\r\n     * Ensure all items that iron list will be looking at are actually defined.\r\n     * If this is not done, the component will keep looking ahead through the\r\n     * array until finding enough present items to render. In our case, that's\r\n     * a really slow way of achieving nothing since the rest of the array is\r\n     * empty.\r\n     */\r\n    const originalAssign = list._assignModels;\r\n    list._assignModels = function () {\r\n      const tempItems = [];\r\n      const start = list._virtualStart;\r\n      const count = Math.min(list.items.length, list._physicalCount);\r\n      for (let i = 0; i < count; i++) {\r\n        if (list.items[start + i] === undefined) {\r\n          tempItems.push(i);\r\n          list.items[start + i] = list.$connector.placeholderItem;\r\n        }\r\n      }\r\n\r\n      originalAssign.apply(list, arguments);\r\n\r\n      /*\r\n       * TODO: Keep track of placeholder items in the \"active\" range and\r\n       * avoid deleting them so that the next pass will be faster. Instead,\r\n       * the end of each pass should only delete placeholders that are no\r\n       * longer needed.\r\n       */\r\n      for (let i = 0; i < tempItems.length; i++) {\r\n        delete list.items[start + tempItems[i]];\r\n      }\r\n\r\n      /*\r\n       * Check if we need to do anything once things have settled down.\r\n       * This method is called multiple times in sequence for the same user\r\n       * action, but we only want to do the check once.\r\n       */\r\n      scheduleUpdateRequest();\r\n    };\r\n\r\n    list.items = [];\r\n\r\n    list.$connector.set = function (index, items) {\r\n      for (let i = 0; i < items.length; i++) {\r\n        const itemsIndex = index + i;\r\n        list.items[itemsIndex] = items[i];\r\n      }\r\n      // Do a full render since dirty detection for splices is broken\r\n      list._render();\r\n    };\r\n\r\n    list.$connector.updateData = function (items) {\r\n      // Find the items by key inside the list update them\r\n      const oldItems = list.items;\r\n      const mapByKey = {};\r\n      let leftToUpdate = items.length;\r\n\r\n      for (let i = 0; i < items.length; i++) {\r\n        const item = items[i];\r\n        mapByKey[item.key] = item;\r\n      }\r\n\r\n      for (let i = 0; i < oldItems.length; i++) {\r\n        const oldItem = oldItems[i];\r\n        const newItem = mapByKey[oldItem.key];\r\n        if (newItem) {\r\n          list.items[i] = newItem;\r\n          list.notifyPath('items.' + i);\r\n          leftToUpdate--;\r\n          if (leftToUpdate == 0) {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    list.$connector.clear = function (index, length) {\r\n      for (let i = 0; i < length; i++) {\r\n        const itemsIndex = index + i;\r\n        delete list.items[itemsIndex];\r\n\r\n        // Most likely a no-op since the affected index isn't in view\r\n        list.notifyPath('items.' + itemsIndex);\r\n      }\r\n    };\r\n\r\n    list.$connector.updateSize = function (newSize) {\r\n      const delta = newSize - list.items.length;\r\n      if (delta > 0) {\r\n        list.items.length = newSize;\r\n\r\n        list.notifySplices('items', [\r\n          {\r\n            index: newSize - delta,\r\n            removed: [],\r\n            addedCount: delta,\r\n            object: list.items,\r\n            type: 'splice'\r\n          }\r\n        ]);\r\n      } else if (delta < 0) {\r\n        const removed = list.items.slice(newSize, list.items.length);\r\n        list.items.splice(newSize);\r\n        list.notifySplices('items', [\r\n          {\r\n            index: newSize,\r\n            removed: removed,\r\n            addedCount: 0,\r\n            object: list.items,\r\n            type: 'splice'\r\n          }\r\n        ]);\r\n      }\r\n    };\r\n\r\n    list.$connector.setPlaceholderItem = function (placeholderItem) {\r\n      if (!placeholderItem) {\r\n        placeholderItem = {};\r\n      }\r\n      placeholderItem.__placeholder = true;\r\n      list.$connector.placeholderItem = placeholderItem;\r\n    };\r\n  }\r\n};\r\n"],
  "mappings": "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",
  "names": []
}
