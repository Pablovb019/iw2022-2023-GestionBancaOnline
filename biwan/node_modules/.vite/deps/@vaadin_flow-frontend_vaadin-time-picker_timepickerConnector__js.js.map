{
  "version": 3,
  "sources": ["../../@vaadin/flow-frontend/vaadin-time-picker/helpers.js", "../../@vaadin/flow-frontend/vaadin-time-picker/timepickerConnector.js"],
  "sourcesContent": ["// map from unicode eastern arabic number characters to arabic numbers\r\nconst EASTERN_ARABIC_DIGIT_MAP = {\r\n  '\\\\u0660': '0',\r\n  '\\\\u0661': '1',\r\n  '\\\\u0662': '2',\r\n  '\\\\u0663': '3',\r\n  '\\\\u0664': '4',\r\n  '\\\\u0665': '5',\r\n  '\\\\u0666': '6',\r\n  '\\\\u0667': '7',\r\n  '\\\\u0668': '8',\r\n  '\\\\u0669': '9'\r\n};\r\n\r\n/**\r\n * Escapes the given string so it can be safely used in a regexp.\r\n *\r\n * @param {string} string\r\n * @return {string}\r\n */\r\nfunction escapeRegExp(string) {\r\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\r\n}\r\n\r\n/**\r\n * Parses eastern arabic number characters to arabic numbers (0-9)\r\n *\r\n * @param {string} digits\r\n * @return {string}\r\n */\r\nfunction parseEasternArabicDigits(digits) {\r\n  return digits.replace(/[\\u0660-\\u0669]/g, function (char) {\r\n    const unicode = '\\\\u0' + char.charCodeAt(0).toString(16);\r\n    return EASTERN_ARABIC_DIGIT_MAP[unicode];\r\n  });\r\n}\r\n\r\n/**\r\n * @param {string} locale\r\n * @param {Date} testTime\r\n * @return {string | null}\r\n */\r\nfunction getAmOrPmString(locale, testTime) {\r\n  const testTimeString = testTime.toLocaleTimeString(locale);\r\n\r\n  // AM/PM string is anything from one letter in eastern arabic to standard two letters,\r\n  // to having space in between, dots ...\r\n  // cannot disqualify whitespace since some locales use a. m. / p. m.\r\n  // TODO when more scripts support is added (than Arabic), need to exclude those numbers too\r\n  const amOrPmRegExp = /[^\\d\\u0660-\\u0669]/;\r\n\r\n  const matches =\r\n    // In most locales, the time ends with AM/PM:\r\n    testTimeString.match(new RegExp(`${amOrPmRegExp.source}+$`, 'g')) ||\r\n    // In some locales, the time starts with AM/PM e.g in Chinese:\r\n    testTimeString.match(new RegExp(`^${amOrPmRegExp.source}+`, 'g'));\r\n\r\n  return matches && matches[0].trim();\r\n}\r\n\r\n/**\r\n * @param {string} locale\r\n * @return {string | null}\r\n */\r\nexport function getSeparator(locale) {\r\n  let timeString = TEST_PM_TIME.toLocaleTimeString(locale);\r\n\r\n  // Since the next regex picks first non-number-whitespace,\r\n  // need to discard possible PM from beginning (eg. chinese locale)\r\n  const pmString = getPmString(locale);\r\n  if (pmString && timeString.startsWith(pmString)) {\r\n    timeString = timeString.replace(pmString, '');\r\n  }\r\n\r\n  const matches = timeString.match(/[^\\u0660-\\u0669\\s\\d]/);\r\n  return matches && matches[0];\r\n}\r\n\r\n/**\r\n * Searches for either an AM or PM token in the given time string\r\n * depending on what is provided in `amOrPmString`.\r\n *\r\n * The search is case and space insensitive.\r\n *\r\n * @example\r\n * `searchAmOrPmToken('1 P M', 'PM')` => `'P M'`\r\n *\r\n * @example\r\n * `searchAmOrPmToken('1 a.m.', 'A. M.')` => `a.m.`\r\n *\r\n * @param {string} timeString\r\n * @param {string} amOrPmString\r\n * @return {string | null}\r\n */\r\nexport function searchAmOrPmToken(timeString, amOrPmString) {\r\n  if (!amOrPmString) return null;\r\n\r\n  // Create a regexp string for searching for AM/PM without space-sensitivity.\r\n  const tokenRegExpString = amOrPmString.split(/\\s*/).map(escapeRegExp).join('\\\\s*');\r\n\r\n  // Create a regexp without case-sensitivity.\r\n  const tokenRegExp = new RegExp(tokenRegExpString, 'i');\r\n\r\n  // Match the regexp against the time string.\r\n  const tokenMatches = timeString.match(tokenRegExp);\r\n  if (tokenMatches) {\r\n    return tokenMatches[0];\r\n  }\r\n}\r\n\r\nexport const TEST_PM_TIME = new Date('August 19, 1975 23:15:30');\r\n\r\nexport const TEST_AM_TIME = new Date('August 19, 1975 05:15:30');\r\n\r\n/**\r\n * @param {string} locale\r\n * @return {string}\r\n */\r\nexport function getPmString(locale) {\r\n  return getAmOrPmString(locale, TEST_PM_TIME);\r\n}\r\n\r\n/**\r\n * @param {string} locale\r\n * @return {string}\r\n */\r\nexport function getAmString(locale) {\r\n  return getAmOrPmString(locale, TEST_AM_TIME);\r\n}\r\n\r\n/**\r\n * @param {string} digits\r\n * @return {number}\r\n */\r\nexport function parseDigitsIntoInteger(digits) {\r\n  return parseInt(parseEasternArabicDigits(digits));\r\n}\r\n\r\n/**\r\n * @param {string} milliseconds\r\n * @return {number}\r\n */\r\nexport function parseMillisecondsIntoInteger(milliseconds) {\r\n  milliseconds = parseEasternArabicDigits(milliseconds);\r\n  // digits are either .1 .01 or .001 so need to \"shift\"\r\n  if (milliseconds.length === 1) {\r\n    milliseconds += '00';\r\n  } else if (milliseconds.length === 2) {\r\n    milliseconds += '0';\r\n  }\r\n  return parseInt(milliseconds);\r\n}\r\n\r\n/**\r\n * @param {string} timeString\r\n * @param {number} milliseconds\r\n * @param {string} amString\r\n * @param {string} pmString\r\n * @return {string}\r\n */\r\nexport function formatMilliseconds(timeString, milliseconds, amString, pmString) {\r\n  // might need to inject milliseconds between seconds and AM/PM\r\n  let cleanedTimeString = timeString;\r\n  if (timeString.endsWith(amString)) {\r\n    cleanedTimeString = timeString.replace(' ' + amString, '');\r\n  } else if (timeString.endsWith(pmString)) {\r\n    cleanedTimeString = timeString.replace(' ' + pmString, '');\r\n  }\r\n  if (milliseconds) {\r\n    let millisecondsString = milliseconds < 10 ? '0' : '';\r\n    millisecondsString += milliseconds < 100 ? '0' : '';\r\n    millisecondsString += milliseconds;\r\n    cleanedTimeString += '.' + millisecondsString;\r\n  } else {\r\n    cleanedTimeString += '.000';\r\n  }\r\n  if (timeString.endsWith(amString)) {\r\n    cleanedTimeString = cleanedTimeString + ' ' + amString;\r\n  } else if (timeString.endsWith(pmString)) {\r\n    cleanedTimeString = cleanedTimeString + ' ' + pmString;\r\n  }\r\n  return cleanedTimeString;\r\n}\r\n", "import {\r\n  TEST_PM_TIME,\r\n  formatMilliseconds,\r\n  parseMillisecondsIntoInteger,\r\n  parseDigitsIntoInteger,\r\n  getAmString,\r\n  getPmString,\r\n  getSeparator,\r\n  searchAmOrPmToken\r\n} from './helpers.js';\r\n\r\n(function () {\r\n  const tryCatchWrapper = function (callback) {\r\n    return window.Vaadin.Flow.tryCatchWrapper(callback, 'Vaadin Time Picker');\r\n  };\r\n\r\n  // Execute callback when predicate returns true.\r\n  // Try again later if predicate returns false.\r\n  function when(predicate, callback, timeout = 0) {\r\n    if (predicate()) {\r\n      callback();\r\n    } else {\r\n      setTimeout(() => when(predicate, callback, 200), timeout);\r\n    }\r\n  }\r\n\r\n  window.Vaadin.Flow.timepickerConnector = {\r\n    initLazy: (timepicker) =>\r\n      tryCatchWrapper(function (timepicker) {\r\n        // Check whether the connector was already initialized for the timepicker\r\n        if (timepicker.$connector) {\r\n          return;\r\n        }\r\n\r\n        timepicker.$connector = {};\r\n\r\n        timepicker.$connector.setLocale = tryCatchWrapper(function (locale) {\r\n          // capture previous value if any\r\n          let previousValueObject;\r\n          if (timepicker.value && timepicker.value !== '') {\r\n            previousValueObject = timepicker.i18n.parseTime(timepicker.value);\r\n          }\r\n\r\n          try {\r\n            // Check whether the locale is supported by the browser or not\r\n            TEST_PM_TIME.toLocaleTimeString(locale);\r\n          } catch (e) {\r\n            locale = 'en-US';\r\n            // FIXME should do a callback for server to throw an exception ?\r\n            throw new Error(\r\n              'vaadin-time-picker: The locale ' +\r\n                locale +\r\n                ' is not supported, falling back to default locale setting(en-US).'\r\n            );\r\n          }\r\n\r\n          // 1. 24 or 12 hour clock, if latter then what are the am/pm strings ?\r\n          const pmString = getPmString(locale);\r\n          const amString = getAmString(locale);\r\n\r\n          // 2. What is the separator ?\r\n          const separator = getSeparator(locale);\r\n\r\n          const includeSeconds = function () {\r\n            return timepicker.step && timepicker.step < 60;\r\n          };\r\n\r\n          const includeMilliSeconds = function () {\r\n            return timepicker.step && timepicker.step < 1;\r\n          };\r\n\r\n          let cachedTimeString;\r\n          let cachedTimeObject;\r\n\r\n          timepicker.i18n = {\r\n            formatTime: tryCatchWrapper(function (timeObject) {\r\n              if (!timeObject) return;\r\n\r\n              const timeToBeFormatted = new Date();\r\n              timeToBeFormatted.setHours(timeObject.hours);\r\n              timeToBeFormatted.setMinutes(timeObject.minutes);\r\n              timeToBeFormatted.setSeconds(timeObject.seconds !== undefined ? timeObject.seconds : 0);\r\n\r\n              // the web component expects the correct granularity used for the time string,\r\n              // thus need to format the time object in correct granularity by passing the format options\r\n              let localeTimeString = timeToBeFormatted.toLocaleTimeString(locale, {\r\n                hour: 'numeric',\r\n                minute: 'numeric',\r\n                second: includeSeconds() ? 'numeric' : undefined\r\n              });\r\n\r\n              // milliseconds not part of the time format API\r\n              if (includeMilliSeconds()) {\r\n                localeTimeString = formatMilliseconds(localeTimeString, timeObject.milliseconds, amString, pmString);\r\n              }\r\n\r\n              return localeTimeString;\r\n            }),\r\n\r\n            parseTime: tryCatchWrapper(function (timeString) {\r\n              if (timeString && timeString === cachedTimeString && cachedTimeObject) {\r\n                return cachedTimeObject;\r\n              }\r\n\r\n              if (!timeString) {\r\n                // when nothing is returned, the component shows the invalid state for the input\r\n                return;\r\n              }\r\n\r\n              const amToken = searchAmOrPmToken(timeString, amString);\r\n              const pmToken = searchAmOrPmToken(timeString, pmString);\r\n\r\n              const numbersOnlyTimeString = timeString\r\n                .replace(amToken || '', '')\r\n                .replace(pmToken || '', '')\r\n                .trim();\r\n\r\n              // A regexp that allows to find the numbers with optional separator and continuing searching after it.\r\n              const numbersRegExp = new RegExp('([\\\\d\\\\u0660-\\\\u0669]){1,2}(?:' + separator + ')?', 'g');\r\n\r\n              let hours = numbersRegExp.exec(numbersOnlyTimeString);\r\n              if (hours) {\r\n                hours = parseDigitsIntoInteger(hours[0].replace(separator, ''));\r\n                // handle 12 am -> 0\r\n                // do not do anything if am & pm are not used or if those are the same,\r\n                // as with locale bg-BG there is always \u0447. at the end of the time\r\n                if (amToken !== pmToken) {\r\n                  if (hours === 12 && amToken) {\r\n                    hours = 0;\r\n                  }\r\n                  if (hours !== 12 && pmToken) {\r\n                    hours += 12;\r\n                  }\r\n                }\r\n                const minutes = numbersRegExp.exec(numbersOnlyTimeString);\r\n                const seconds = minutes && numbersRegExp.exec(numbersOnlyTimeString);\r\n                // detecting milliseconds from input, expects am/pm removed from end, eg. .0 or .00 or .000\r\n                const millisecondRegExp = /[[\\.][\\d\\u0660-\\u0669]{1,3}$/;\r\n                // reset to end or things can explode\r\n                let milliseconds = seconds && includeMilliSeconds() && millisecondRegExp.exec(numbersOnlyTimeString);\r\n                // handle case where last numbers are seconds and . is the separator (invalid regexp match)\r\n                if (milliseconds && milliseconds['index'] <= seconds['index']) {\r\n                  milliseconds = undefined;\r\n                }\r\n                // hours is a number at this point, others are either arrays or null\r\n                // the string in [0] from the arrays includes the separator too\r\n                cachedTimeObject = hours !== undefined && {\r\n                  hours: hours,\r\n                  minutes: minutes ? parseDigitsIntoInteger(minutes[0].replace(separator, '')) : 0,\r\n                  seconds: seconds ? parseDigitsIntoInteger(seconds[0].replace(separator, '')) : 0,\r\n                  milliseconds:\r\n                    minutes && seconds && milliseconds\r\n                      ? parseMillisecondsIntoInteger(milliseconds[0].replace('.', ''))\r\n                      : 0\r\n                };\r\n                cachedTimeString = timeString;\r\n                return cachedTimeObject;\r\n              }\r\n            })\r\n          };\r\n\r\n          if (previousValueObject) {\r\n            when(\r\n              () => timepicker.$,\r\n              () => {\r\n                const newValue = timepicker.i18n.formatTime(previousValueObject);\r\n                // FIXME works but uses private API, needs fixes in web component\r\n                if (timepicker.inputElement.value !== newValue) {\r\n                  timepicker.inputElement.value = newValue;\r\n                  timepicker.$.comboBox.value = newValue;\r\n                }\r\n              }\r\n            );\r\n          }\r\n        });\r\n      })(timepicker)\r\n  };\r\n})();\r\n"],
  "mappings": ";;;AACA,IAAM,2BAA2B;AAAA,EAC/B,WAAW;AAAA,EACX,WAAW;AAAA,EACX,WAAW;AAAA,EACX,WAAW;AAAA,EACX,WAAW;AAAA,EACX,WAAW;AAAA,EACX,WAAW;AAAA,EACX,WAAW;AAAA,EACX,WAAW;AAAA,EACX,WAAW;AACb;AAQA,SAAS,aAAa,QAAQ;AAC5B,SAAO,OAAO,QAAQ,uBAAuB,MAAM;AACrD;AAQA,SAAS,yBAAyB,QAAQ;AACxC,SAAO,OAAO,QAAQ,oBAAoB,SAAU,MAAM;AACxD,UAAM,UAAU,SAAS,KAAK,WAAW,CAAC,EAAE,SAAS,EAAE;AACvD,WAAO,yBAAyB;AAAA,EAClC,CAAC;AACH;AAOA,SAAS,gBAAgB,QAAQ,UAAU;AACzC,QAAM,iBAAiB,SAAS,mBAAmB,MAAM;AAMzD,QAAM,eAAe;AAErB,QAAM,UAEJ,eAAe,MAAM,IAAI,OAAO,GAAG,aAAa,YAAY,GAAG,CAAC,KAEhE,eAAe,MAAM,IAAI,OAAO,IAAI,aAAa,WAAW,GAAG,CAAC;AAElE,SAAO,WAAW,QAAQ,GAAG,KAAK;AACpC;AAMO,SAAS,aAAa,QAAQ;AACnC,MAAI,aAAa,aAAa,mBAAmB,MAAM;AAIvD,QAAM,WAAW,YAAY,MAAM;AACnC,MAAI,YAAY,WAAW,WAAW,QAAQ,GAAG;AAC/C,iBAAa,WAAW,QAAQ,UAAU,EAAE;AAAA,EAC9C;AAEA,QAAM,UAAU,WAAW,MAAM,sBAAsB;AACvD,SAAO,WAAW,QAAQ;AAC5B;AAkBO,SAAS,kBAAkB,YAAY,cAAc;AAC1D,MAAI,CAAC;AAAc,WAAO;AAG1B,QAAM,oBAAoB,aAAa,MAAM,KAAK,EAAE,IAAI,YAAY,EAAE,KAAK,MAAM;AAGjF,QAAM,cAAc,IAAI,OAAO,mBAAmB,GAAG;AAGrD,QAAM,eAAe,WAAW,MAAM,WAAW;AACjD,MAAI,cAAc;AAChB,WAAO,aAAa;AAAA,EACtB;AACF;AAEO,IAAM,eAAe,IAAI,KAAK,0BAA0B;AAExD,IAAM,eAAe,IAAI,KAAK,0BAA0B;AAMxD,SAAS,YAAY,QAAQ;AAClC,SAAO,gBAAgB,QAAQ,YAAY;AAC7C;AAMO,SAAS,YAAY,QAAQ;AAClC,SAAO,gBAAgB,QAAQ,YAAY;AAC7C;AAMO,SAAS,uBAAuB,QAAQ;AAC7C,SAAO,SAAS,yBAAyB,MAAM,CAAC;AAClD;AAMO,SAAS,6BAA6B,cAAc;AACzD,iBAAe,yBAAyB,YAAY;AAEpD,MAAI,aAAa,WAAW,GAAG;AAC7B,oBAAgB;AAAA,EAClB,WAAW,aAAa,WAAW,GAAG;AACpC,oBAAgB;AAAA,EAClB;AACA,SAAO,SAAS,YAAY;AAC9B;AASO,SAAS,mBAAmB,YAAY,cAAc,UAAU,UAAU;AAE/E,MAAI,oBAAoB;AACxB,MAAI,WAAW,SAAS,QAAQ,GAAG;AACjC,wBAAoB,WAAW,QAAQ,MAAM,UAAU,EAAE;AAAA,EAC3D,WAAW,WAAW,SAAS,QAAQ,GAAG;AACxC,wBAAoB,WAAW,QAAQ,MAAM,UAAU,EAAE;AAAA,EAC3D;AACA,MAAI,cAAc;AAChB,QAAI,qBAAqB,eAAe,KAAK,MAAM;AACnD,0BAAsB,eAAe,MAAM,MAAM;AACjD,0BAAsB;AACtB,yBAAqB,MAAM;AAAA,EAC7B,OAAO;AACL,yBAAqB;AAAA,EACvB;AACA,MAAI,WAAW,SAAS,QAAQ,GAAG;AACjC,wBAAoB,oBAAoB,MAAM;AAAA,EAChD,WAAW,WAAW,SAAS,QAAQ,GAAG;AACxC,wBAAoB,oBAAoB,MAAM;AAAA,EAChD;AACA,SAAO;AACT;;;CC3KC,WAAY;AACX,QAAM,kBAAkB,SAAU,UAAU;AAC1C,WAAO,OAAO,OAAO,KAAK,gBAAgB,UAAU,oBAAoB;AAAA,EAC1E;AAIA,WAAS,KAAK,WAAW,UAAU,UAAU,GAAG;AAC9C,QAAI,UAAU,GAAG;AACf,eAAS;AAAA,IACX,OAAO;AACL,iBAAW,MAAM,KAAK,WAAW,UAAU,GAAG,GAAG,OAAO;AAAA,IAC1D;AAAA,EACF;AAEA,SAAO,OAAO,KAAK,sBAAsB;AAAA,IACvC,UAAU,CAAC,eACT,gBAAgB,SAAUA,aAAY;AAEpC,UAAIA,YAAW,YAAY;AACzB;AAAA,MACF;AAEA,MAAAA,YAAW,aAAa,CAAC;AAEzB,MAAAA,YAAW,WAAW,YAAY,gBAAgB,SAAU,QAAQ;AAElE,YAAI;AACJ,YAAIA,YAAW,SAASA,YAAW,UAAU,IAAI;AAC/C,gCAAsBA,YAAW,KAAK,UAAUA,YAAW,KAAK;AAAA,QAClE;AAEA,YAAI;AAEF,uBAAa,mBAAmB,MAAM;AAAA,QACxC,SAAS,GAAP;AACA,mBAAS;AAET,gBAAM,IAAI;AAAA,YACR,oCACE,SACA;AAAA,UACJ;AAAA,QACF;AAGA,cAAM,WAAW,YAAY,MAAM;AACnC,cAAM,WAAW,YAAY,MAAM;AAGnC,cAAM,YAAY,aAAa,MAAM;AAErC,cAAM,iBAAiB,WAAY;AACjC,iBAAOA,YAAW,QAAQA,YAAW,OAAO;AAAA,QAC9C;AAEA,cAAM,sBAAsB,WAAY;AACtC,iBAAOA,YAAW,QAAQA,YAAW,OAAO;AAAA,QAC9C;AAEA,YAAI;AACJ,YAAI;AAEJ,QAAAA,YAAW,OAAO;AAAA,UAChB,YAAY,gBAAgB,SAAU,YAAY;AAChD,gBAAI,CAAC;AAAY;AAEjB,kBAAM,oBAAoB,IAAI,KAAK;AACnC,8BAAkB,SAAS,WAAW,KAAK;AAC3C,8BAAkB,WAAW,WAAW,OAAO;AAC/C,8BAAkB,WAAW,WAAW,YAAY,SAAY,WAAW,UAAU,CAAC;AAItF,gBAAI,mBAAmB,kBAAkB,mBAAmB,QAAQ;AAAA,cAClE,MAAM;AAAA,cACN,QAAQ;AAAA,cACR,QAAQ,eAAe,IAAI,YAAY;AAAA,YACzC,CAAC;AAGD,gBAAI,oBAAoB,GAAG;AACzB,iCAAmB,mBAAmB,kBAAkB,WAAW,cAAc,UAAU,QAAQ;AAAA,YACrG;AAEA,mBAAO;AAAA,UACT,CAAC;AAAA,UAED,WAAW,gBAAgB,SAAU,YAAY;AAC/C,gBAAI,cAAc,eAAe,oBAAoB,kBAAkB;AACrE,qBAAO;AAAA,YACT;AAEA,gBAAI,CAAC,YAAY;AAEf;AAAA,YACF;AAEA,kBAAM,UAAU,kBAAkB,YAAY,QAAQ;AACtD,kBAAM,UAAU,kBAAkB,YAAY,QAAQ;AAEtD,kBAAM,wBAAwB,WAC3B,QAAQ,WAAW,IAAI,EAAE,EACzB,QAAQ,WAAW,IAAI,EAAE,EACzB,KAAK;AAGR,kBAAM,gBAAgB,IAAI,OAAO,mCAAmC,YAAY,MAAM,GAAG;AAEzF,gBAAI,QAAQ,cAAc,KAAK,qBAAqB;AACpD,gBAAI,OAAO;AACT,sBAAQ,uBAAuB,MAAM,GAAG,QAAQ,WAAW,EAAE,CAAC;AAI9D,kBAAI,YAAY,SAAS;AACvB,oBAAI,UAAU,MAAM,SAAS;AAC3B,0BAAQ;AAAA,gBACV;AACA,oBAAI,UAAU,MAAM,SAAS;AAC3B,2BAAS;AAAA,gBACX;AAAA,cACF;AACA,oBAAM,UAAU,cAAc,KAAK,qBAAqB;AACxD,oBAAM,UAAU,WAAW,cAAc,KAAK,qBAAqB;AAEnE,oBAAM,oBAAoB;AAE1B,kBAAI,eAAe,WAAW,oBAAoB,KAAK,kBAAkB,KAAK,qBAAqB;AAEnG,kBAAI,gBAAgB,aAAa,YAAY,QAAQ,UAAU;AAC7D,+BAAe;AAAA,cACjB;AAGA,iCAAmB,UAAU,UAAa;AAAA,gBACxC;AAAA,gBACA,SAAS,UAAU,uBAAuB,QAAQ,GAAG,QAAQ,WAAW,EAAE,CAAC,IAAI;AAAA,gBAC/E,SAAS,UAAU,uBAAuB,QAAQ,GAAG,QAAQ,WAAW,EAAE,CAAC,IAAI;AAAA,gBAC/E,cACE,WAAW,WAAW,eAClB,6BAA6B,aAAa,GAAG,QAAQ,KAAK,EAAE,CAAC,IAC7D;AAAA,cACR;AACA,iCAAmB;AACnB,qBAAO;AAAA,YACT;AAAA,UACF,CAAC;AAAA,QACH;AAEA,YAAI,qBAAqB;AACvB;AAAA,YACE,MAAMA,YAAW;AAAA,YACjB,MAAM;AACJ,oBAAM,WAAWA,YAAW,KAAK,WAAW,mBAAmB;AAE/D,kBAAIA,YAAW,aAAa,UAAU,UAAU;AAC9C,gBAAAA,YAAW,aAAa,QAAQ;AAChC,gBAAAA,YAAW,EAAE,SAAS,QAAQ;AAAA,cAChC;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IACH,CAAC,EAAE,UAAU;AAAA,EACjB;AACF,GAAG;",
  "names": ["timepicker"]
}
