{
  "version": 3,
  "sources": ["../../@vaadin/flow-frontend/comboBoxConnector.js"],
  "sourcesContent": ["import { Debouncer } from '@polymer/polymer/lib/utils/debounce.js';\r\nimport { timeOut } from '@polymer/polymer/lib/utils/async.js';\r\nimport { ComboBoxPlaceholder } from '@vaadin/combo-box/src/vaadin-combo-box-placeholder.js';\r\n\r\n(function () {\r\n  const tryCatchWrapper = function (callback) {\r\n    return window.Vaadin.Flow.tryCatchWrapper(callback, 'Vaadin Combo Box');\r\n  };\r\n\r\n  window.Vaadin.Flow.comboBoxConnector = {\r\n    initLazy: (comboBox) =>\r\n      tryCatchWrapper(function (comboBox) {\r\n        // Check whether the connector was already initialized for the ComboBox\r\n        if (comboBox.$connector) {\r\n          return;\r\n        }\r\n\r\n        comboBox.$connector = {};\r\n\r\n        /**\r\n         * Returns the element that implements the data provider mixin.\r\n         * For <vaadin-combo-box> that is the element itself.\r\n         * <vaadin-multi-select-combo-box> wraps a regular combo box internally,\r\n         * which is returned in this case.\r\n         * @returns {Node|Element|*}\r\n         */\r\n        function getDataProviderMixin() {\r\n          return comboBox.localName === 'vaadin-multi-select-combo-box' ? comboBox.$.comboBox : comboBox;\r\n        }\r\n\r\n        // holds pageIndex -> callback pairs of subsequent indexes (current active range)\r\n        const pageCallbacks = {};\r\n        let cache = {};\r\n        let lastFilter = '';\r\n        const placeHolder = new window.Vaadin.ComboBoxPlaceholder();\r\n        const MAX_RANGE_COUNT = Math.max(comboBox.pageSize * 2, 500); // Max item count in active range\r\n\r\n        const serverFacade = (() => {\r\n          // Private variables\r\n          let lastFilterSentToServer = '';\r\n          let dataCommunicatorResetNeeded = false;\r\n\r\n          // Public methods\r\n          const needsDataCommunicatorReset = () => (dataCommunicatorResetNeeded = true);\r\n          const getLastFilterSentToServer = () => lastFilterSentToServer;\r\n          const requestData = (startIndex, endIndex, params) => {\r\n            const count = endIndex - startIndex;\r\n            const filter = params.filter;\r\n\r\n            comboBox.$server.setRequestedRange(startIndex, count, filter);\r\n            lastFilterSentToServer = filter;\r\n            if (dataCommunicatorResetNeeded) {\r\n              comboBox.$server.resetDataCommunicator();\r\n              dataCommunicatorResetNeeded = false;\r\n            }\r\n          };\r\n\r\n          return {\r\n            needsDataCommunicatorReset,\r\n            getLastFilterSentToServer,\r\n            requestData\r\n          };\r\n        })();\r\n\r\n        const clearPageCallbacks = (pages = Object.keys(pageCallbacks)) => {\r\n          const dataProviderMixin = getDataProviderMixin();\r\n          // Flush and empty the existing requests\r\n          pages.forEach((page) => {\r\n            pageCallbacks[page]([], dataProviderMixin.size);\r\n            delete pageCallbacks[page];\r\n\r\n            // Empty the comboBox's internal cache without invoking observers by filling\r\n            // the filteredItems array with placeholders (comboBox will request for data when it\r\n            // encounters a placeholder)\r\n            const pageStart = parseInt(page) * dataProviderMixin.pageSize;\r\n            const pageEnd = pageStart + dataProviderMixin.pageSize;\r\n            const end = Math.min(pageEnd, dataProviderMixin.filteredItems.length);\r\n            for (let i = pageStart; i < end; i++) {\r\n              dataProviderMixin.filteredItems[i] = placeHolder;\r\n            }\r\n          });\r\n        };\r\n\r\n        comboBox.dataProvider = function (params, callback) {\r\n          if (params.pageSize != comboBox.pageSize) {\r\n            throw 'Invalid pageSize';\r\n          }\r\n\r\n          if (comboBox._clientSideFilter) {\r\n            // For clientside filter we first make sure we have all data which we also\r\n            // filter based on comboBox.filter. While later we only filter clientside data.\r\n\r\n            if (cache[0]) {\r\n              performClientSideFilter(cache[0], callback);\r\n              return;\r\n            } else {\r\n              // If client side filter is enabled then we need to first ask all data\r\n              // and filter it on client side, otherwise next time when user will\r\n              // input another filter, eg. continue to type, the local cache will be only\r\n              // what was received for the first filter, which may not be the whole\r\n              // data from server (keep in mind that client side filter is enabled only\r\n              // when the items count does not exceed one page).\r\n              params.filter = '';\r\n            }\r\n          }\r\n\r\n          const filterChanged = params.filter !== lastFilter;\r\n          if (filterChanged) {\r\n            cache = {};\r\n            lastFilter = params.filter;\r\n            this._filterDebouncer = Debouncer.debounce(this._filterDebouncer, timeOut.after(500), () => {\r\n              if (serverFacade.getLastFilterSentToServer() === params.filter) {\r\n                // Fixes the case when the filter changes\r\n                // to something else and back to the original value\r\n                // within debounce timeout, and the\r\n                // DataCommunicator thinks it doesn't need to send data\r\n                serverFacade.needsDataCommunicatorReset();\r\n              }\r\n              if (params.filter !== lastFilter) {\r\n                throw new Error(\"Expected params.filter to be '\" + lastFilter + \"' but was '\" + params.filter + \"'\");\r\n              }\r\n              // Remove the debouncer before clearing page callbacks.\r\n              // This makes sure that they are executed.\r\n              this._filterDebouncer = undefined;\r\n              // Call the method again after debounce.\r\n              clearPageCallbacks();\r\n              comboBox.dataProvider(params, callback);\r\n            });\r\n            return;\r\n          }\r\n\r\n          // Postpone the execution of new callbacks if there is an active debouncer.\r\n          // They will be executed when the page callbacks are cleared within the debouncer.\r\n          if (this._filterDebouncer) {\r\n            pageCallbacks[params.page] = callback;\r\n            return;\r\n          }\r\n\r\n          if (cache[params.page]) {\r\n            // This may happen after skipping pages by scrolling fast\r\n            commitPage(params.page, callback);\r\n          } else {\r\n            pageCallbacks[params.page] = callback;\r\n            const activePages = Object.keys(pageCallbacks).map((page) => parseInt(page));\r\n            const rangeMin = Math.min(...activePages);\r\n            const rangeMax = Math.max(...activePages);\r\n\r\n            if (activePages.length * params.pageSize > MAX_RANGE_COUNT) {\r\n              if (params.page === rangeMin) {\r\n                clearPageCallbacks([String(rangeMax)]);\r\n              } else {\r\n                clearPageCallbacks([String(rangeMin)]);\r\n              }\r\n              comboBox.dataProvider(params, callback);\r\n            } else if (rangeMax - rangeMin + 1 !== activePages.length) {\r\n              // Wasn't a sequential page index, clear the cache so combo-box will request for new pages\r\n              clearPageCallbacks();\r\n            } else {\r\n              // The requested page was sequential, extend the requested range\r\n              const startIndex = params.pageSize * rangeMin;\r\n              const endIndex = params.pageSize * (rangeMax + 1);\r\n\r\n              serverFacade.requestData(startIndex, endIndex, params);\r\n            }\r\n          }\r\n        };\r\n\r\n        comboBox.$connector.clear = tryCatchWrapper((start, length) => {\r\n          const firstPageToClear = Math.floor(start / comboBox.pageSize);\r\n          const numberOfPagesToClear = Math.ceil(length / comboBox.pageSize);\r\n\r\n          for (let i = firstPageToClear; i < firstPageToClear + numberOfPagesToClear; i++) {\r\n            delete cache[i];\r\n          }\r\n        });\r\n\r\n        comboBox.$connector.filter = tryCatchWrapper(function (item, filter) {\r\n          filter = filter ? filter.toString().toLowerCase() : '';\r\n          return comboBox._getItemLabel(item, comboBox.itemLabelPath).toString().toLowerCase().indexOf(filter) > -1;\r\n        });\r\n\r\n        comboBox.$connector.set = tryCatchWrapper(function (index, items, filter) {\r\n          if (filter != serverFacade.getLastFilterSentToServer()) {\r\n            return;\r\n          }\r\n\r\n          if (index % comboBox.pageSize != 0) {\r\n            throw 'Got new data to index ' + index + ' which is not aligned with the page size of ' + comboBox.pageSize;\r\n          }\r\n\r\n          if (index === 0 && items.length === 0 && pageCallbacks[0]) {\r\n            // Makes sure that the dataProvider callback is called even when server\r\n            // returns empty data set (no items match the filter).\r\n            cache[0] = [];\r\n            return;\r\n          }\r\n\r\n          const firstPageToSet = index / comboBox.pageSize;\r\n          const updatedPageCount = Math.ceil(items.length / comboBox.pageSize);\r\n\r\n          for (let i = 0; i < updatedPageCount; i++) {\r\n            let page = firstPageToSet + i;\r\n            let slice = items.slice(i * comboBox.pageSize, (i + 1) * comboBox.pageSize);\r\n\r\n            cache[page] = slice;\r\n          }\r\n        });\r\n\r\n        comboBox.$connector.updateData = tryCatchWrapper(function (items) {\r\n          const dataProviderMixin = getDataProviderMixin();\r\n\r\n          const itemsMap = new Map(items.map((item) => [item.key, item]));\r\n\r\n          dataProviderMixin.filteredItems = dataProviderMixin.filteredItems.map((item) => {\r\n            return itemsMap.get(item.key) || item;\r\n          });\r\n        });\r\n\r\n        comboBox.$connector.updateSize = tryCatchWrapper(function (newSize) {\r\n          if (!comboBox._clientSideFilter) {\r\n            // FIXME: It may be that this size set is unnecessary, since when\r\n            // providing data to combobox via callback we may use data's size.\r\n            // However, if this size reflect the whole data size, including\r\n            // data not fetched yet into client side, and combobox expect it\r\n            // to be set as such, the at least, we don't need it in case the\r\n            // filter is clientSide only, since it'll increase the height of\r\n            // the popup at only at first user filter to this size, while the\r\n            // filtered items count are less.\r\n            comboBox.size = newSize;\r\n          }\r\n        });\r\n\r\n        comboBox.$connector.reset = tryCatchWrapper(function () {\r\n          const dataProviderMixin = getDataProviderMixin();\r\n          clearPageCallbacks();\r\n          cache = {};\r\n          dataProviderMixin.clearCache();\r\n        });\r\n\r\n        comboBox.$connector.confirm = tryCatchWrapper(function (id, filter) {\r\n          if (filter != serverFacade.getLastFilterSentToServer()) {\r\n            return;\r\n          }\r\n\r\n          // We're done applying changes from this batch, resolve pending\r\n          // callbacks\r\n          let activePages = Object.getOwnPropertyNames(pageCallbacks);\r\n          for (let i = 0; i < activePages.length; i++) {\r\n            let page = activePages[i];\r\n\r\n            if (cache[page]) {\r\n              commitPage(page, pageCallbacks[page]);\r\n            }\r\n          }\r\n\r\n          // Let server know we're done\r\n          comboBox.$server.confirmUpdate(id);\r\n        });\r\n\r\n        comboBox.$connector.enableClientValidation = tryCatchWrapper(function (enable) {\r\n          if (comboBox.$) {\r\n            if (enable) {\r\n              enableClientValidation(comboBox);\r\n            } else {\r\n              disableClientValidation(comboBox);\r\n            }\r\n\r\n            comboBox.validate();\r\n          } else {\r\n            setTimeout(function () {\r\n              comboBox.$connector.enableClientValidation(enable);\r\n            }, 10);\r\n          }\r\n        });\r\n\r\n        const disableClientValidation = tryCatchWrapper(function (combo) {\r\n          if (typeof combo.$checkValidity == 'undefined') {\r\n            combo.$checkValidity = combo.checkValidity;\r\n            combo.checkValidity = function () {\r\n              return !comboBox.invalid;\r\n            };\r\n          }\r\n          if (typeof combo.$validate == 'undefined') {\r\n            combo.$validate = combo.validate;\r\n            combo.validate = function () {\r\n              return !(comboBox.focusElement.invalid = comboBox.invalid);\r\n            };\r\n          }\r\n        });\r\n\r\n        const enableClientValidation = tryCatchWrapper(function (combo) {\r\n          if (combo.$checkValidity) {\r\n            combo.checkValidity = combo.$checkValidity;\r\n            delete combo.$checkValidity;\r\n          }\r\n          if (combo.$validate) {\r\n            combo.validate = combo.$validate;\r\n            delete combo.$validate;\r\n          }\r\n        });\r\n\r\n        const commitPage = tryCatchWrapper(function (page, callback) {\r\n          let data = cache[page];\r\n\r\n          if (comboBox._clientSideFilter) {\r\n            performClientSideFilter(data, callback);\r\n          } else {\r\n            // Remove the data if server-side filtering, but keep it for client-side\r\n            // filtering\r\n            delete cache[page];\r\n\r\n            // FIXME: It may be that we ought to provide data.length instead of\r\n            // comboBox.size and remove updateSize function.\r\n            callback(data, comboBox.size);\r\n          }\r\n        });\r\n\r\n        // Perform filter on client side (here) using the items from specified page\r\n        // and submitting the filtered items to specified callback.\r\n        // The filter used is the one from combobox, not the lastFilter stored since\r\n        // that may not reflect user's input.\r\n        const performClientSideFilter = tryCatchWrapper(function (page, callback) {\r\n          const dataProviderMixin = getDataProviderMixin();\r\n          let filteredItems = page;\r\n\r\n          if (dataProviderMixin.filter) {\r\n            filteredItems = page.filter((item) => comboBox.$connector.filter(item, dataProviderMixin.filter));\r\n          }\r\n\r\n          callback(filteredItems, filteredItems.length);\r\n        });\r\n\r\n        // Prevent setting the custom value as the 'value'-prop automatically\r\n        comboBox.addEventListener(\r\n          'custom-value-set',\r\n          tryCatchWrapper((e) => e.preventDefault())\r\n        );\r\n      })(comboBox)\r\n  };\r\n})();\r\n\r\nwindow.Vaadin.ComboBoxPlaceholder = ComboBoxPlaceholder;\r\n"],
  "mappings": "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",
  "names": ["comboBox"]
}
