{
  "version": 3,
  "sources": ["../../@vaadin/flow-frontend/gridConnector.js"],
  "sourcesContent": ["import { Debouncer } from '@polymer/polymer/lib/utils/debounce.js';\r\nimport { timeOut, animationFrame } from '@polymer/polymer/lib/utils/async.js';\r\nimport { Grid } from '@vaadin/grid/src/vaadin-grid.js';\r\nimport { ItemCache } from '@vaadin/grid/src/vaadin-grid-data-provider-mixin.js';\r\nimport { isFocusable } from '@vaadin/grid/src/vaadin-grid-active-item-mixin.js';\r\n\r\n(function () {\r\n  const tryCatchWrapper = function (callback) {\r\n    return window.Vaadin.Flow.tryCatchWrapper(callback, 'Vaadin Grid');\r\n  };\r\n\r\n  let isItemCacheInitialized = false;\r\n\r\n  window.Vaadin.Flow.gridConnector = {\r\n    initLazy: (grid) =>\r\n      tryCatchWrapper(function (grid) {\r\n        // Check whether the connector was already initialized for the grid\r\n        if (grid.$connector) {\r\n          return;\r\n        }\r\n\r\n        // Make sure ItemCache patching is done only once, but delay it for when\r\n        // a server grid is initialized\r\n        if (!isItemCacheInitialized) {\r\n          isItemCacheInitialized = true;\r\n          // Storing original implementation of the method to be used for client\r\n          // side only grids\r\n          ItemCache.prototype.ensureSubCacheForScaledIndexOriginal = ItemCache.prototype.ensureSubCacheForScaledIndex;\r\n          ItemCache.prototype.ensureSubCacheForScaledIndex = tryCatchWrapper(function (scaledIndex) {\r\n            if (!this.grid.$connector) {\r\n              this.ensureSubCacheForScaledIndexOriginal(scaledIndex);\r\n              return;\r\n            }\r\n\r\n            if (!this.itemCaches[scaledIndex]) {\r\n              this.grid.$connector.beforeEnsureSubCacheForScaledIndex(this, scaledIndex);\r\n            }\r\n          });\r\n\r\n          ItemCache.prototype.isLoadingOriginal = ItemCache.prototype.isLoading;\r\n          ItemCache.prototype.isLoading = tryCatchWrapper(function () {\r\n            if (!this.grid.$connector) {\r\n              return this.isLoadingOriginal();\r\n            }\r\n\r\n            return Boolean(\r\n              this.grid.$connector.hasEnsureSubCacheQueue() ||\r\n                Object.keys(this.pendingRequests).length ||\r\n                Object.keys(this.itemCaches).filter((index) => {\r\n                  return this.itemCaches[index].isLoading();\r\n                })[0]\r\n            );\r\n          });\r\n\r\n          ItemCache.prototype.doEnsureSubCacheForScaledIndex = tryCatchWrapper(function (scaledIndex) {\r\n            if (!this.itemCaches[scaledIndex]) {\r\n              const subCache = new ItemCache.prototype.constructor(this.grid, this, this.items[scaledIndex]);\r\n              subCache.itemkeyCaches = {};\r\n              if (!this.itemkeyCaches) {\r\n                this.itemkeyCaches = {};\r\n              }\r\n              this.itemCaches[scaledIndex] = subCache;\r\n              this.itemkeyCaches[this.grid.getItemId(subCache.parentItem)] = subCache;\r\n              this.grid._loadPage(0, subCache);\r\n            }\r\n          });\r\n\r\n          ItemCache.prototype.getCacheAndIndexByKey = tryCatchWrapper(function (key) {\r\n            for (let index in this.items) {\r\n              if (this.grid.getItemId(this.items[index]) === key) {\r\n                return { cache: this, scaledIndex: index };\r\n              }\r\n            }\r\n            const keys = Object.keys(this.itemkeyCaches);\r\n            for (let i = 0; i < keys.length; i++) {\r\n              const expandedKey = keys[i];\r\n              const subCache = this.itemkeyCaches[expandedKey];\r\n              let cacheAndIndex = subCache.getCacheAndIndexByKey(key);\r\n              if (cacheAndIndex) {\r\n                return cacheAndIndex;\r\n              }\r\n            }\r\n            return undefined;\r\n          });\r\n\r\n          ItemCache.prototype.getLevel = tryCatchWrapper(function () {\r\n            let cache = this;\r\n            let level = 0;\r\n            while (cache.parentCache) {\r\n              cache = cache.parentCache;\r\n              level++;\r\n            }\r\n            return level;\r\n          });\r\n        }\r\n\r\n        const rootPageCallbacks = {};\r\n        const treePageCallbacks = {};\r\n        const cache = {};\r\n\r\n        /* parentRequestDelay - optimizes parent requests by batching several requests\r\n         *  into one request. Delay in milliseconds. Disable by setting to 0.\r\n         *  parentRequestBatchMaxSize - maximum size of the batch.\r\n         */\r\n        const parentRequestDelay = 50;\r\n        const parentRequestBatchMaxSize = 20;\r\n\r\n        let parentRequestQueue = [];\r\n        let parentRequestDebouncer;\r\n        let ensureSubCacheQueue = [];\r\n        let ensureSubCacheDebouncer;\r\n\r\n        const rootRequestDelay = 150;\r\n        let rootRequestDebouncer;\r\n\r\n        let lastRequestedRanges = {};\r\n        const root = 'null';\r\n        lastRequestedRanges[root] = [0, 0];\r\n\r\n        const validSelectionModes = ['SINGLE', 'NONE', 'MULTI'];\r\n        let selectedKeys = {};\r\n        let selectionMode = 'SINGLE';\r\n\r\n        let sorterDirectionsSetFromServer = false;\r\n\r\n        grid.size = 0; // To avoid NaN here and there before we get proper data\r\n        grid.itemIdPath = 'key';\r\n\r\n        grid.$connector = {};\r\n\r\n        grid.$connector.hasEnsureSubCacheQueue = tryCatchWrapper(() => ensureSubCacheQueue.length > 0);\r\n\r\n        grid.$connector.hasParentRequestQueue = tryCatchWrapper(() => parentRequestQueue.length > 0);\r\n\r\n        grid.$connector.hasRootRequestQueue = tryCatchWrapper(() => {\r\n          return Object.keys(rootPageCallbacks).length > 0 || (rootRequestDebouncer && rootRequestDebouncer.isActive());\r\n        });\r\n\r\n        grid.$connector.beforeEnsureSubCacheForScaledIndex = tryCatchWrapper(function (targetCache, scaledIndex) {\r\n          // add call to queue\r\n          ensureSubCacheQueue.push({\r\n            cache: targetCache,\r\n            scaledIndex: scaledIndex,\r\n            itemkey: grid.getItemId(targetCache.items[scaledIndex]),\r\n            level: targetCache.getLevel()\r\n          });\r\n\r\n          ensureSubCacheDebouncer = Debouncer.debounce(ensureSubCacheDebouncer, animationFrame, () => {\r\n            while (ensureSubCacheQueue.length) {\r\n              grid.$connector.flushEnsureSubCache();\r\n            }\r\n          });\r\n        });\r\n\r\n        grid.$connector.doSelection = tryCatchWrapper(function (items, userOriginated) {\r\n          if (selectionMode === 'NONE' || !items.length || (userOriginated && grid.hasAttribute('disabled'))) {\r\n            return;\r\n          }\r\n          if (selectionMode === 'SINGLE') {\r\n            grid.selectedItems = [];\r\n            selectedKeys = {};\r\n          }\r\n\r\n          // For single selection mode, \"deselect all\" selects a single item `null`,\r\n          // which should not end up in the selected items\r\n          const sanitizedItems = items.filter((item) => item !== null);\r\n          grid.selectedItems = grid.selectedItems.concat(sanitizedItems);\r\n\r\n          items.forEach((item) => {\r\n            if (item) {\r\n              selectedKeys[item.key] = item;\r\n              if (userOriginated) {\r\n                item.selected = true;\r\n                grid.$server.select(item.key);\r\n              }\r\n            }\r\n            const isSelectedItemDifferentOrNull = !grid.activeItem || !item || item.key != grid.activeItem.key;\r\n            if (!userOriginated && selectionMode === 'SINGLE' && isSelectedItemDifferentOrNull) {\r\n              grid.activeItem = item;\r\n            }\r\n          });\r\n        });\r\n\r\n        grid.$connector.doDeselection = tryCatchWrapper(function (items, userOriginated) {\r\n          if (selectionMode === 'NONE' || !items.length || (userOriginated && grid.hasAttribute('disabled'))) {\r\n            return;\r\n          }\r\n\r\n          const updatedSelectedItems = grid.selectedItems.slice();\r\n          while (items.length) {\r\n            const itemToDeselect = items.shift();\r\n            for (let i = 0; i < updatedSelectedItems.length; i++) {\r\n              const selectedItem = updatedSelectedItems[i];\r\n              if (itemToDeselect && itemToDeselect.key === selectedItem.key) {\r\n                updatedSelectedItems.splice(i, 1);\r\n                break;\r\n              }\r\n            }\r\n            if (itemToDeselect) {\r\n              delete selectedKeys[itemToDeselect.key];\r\n              if (userOriginated) {\r\n                delete itemToDeselect.selected;\r\n                grid.$server.deselect(itemToDeselect.key);\r\n              }\r\n            }\r\n          }\r\n          grid.selectedItems = updatedSelectedItems;\r\n        });\r\n\r\n        grid.__activeItemChanged = tryCatchWrapper(function (newVal, oldVal) {\r\n          if (selectionMode != 'SINGLE') {\r\n            return;\r\n          }\r\n          if (!newVal) {\r\n            if (oldVal && selectedKeys[oldVal.key]) {\r\n              if (grid.__deselectDisallowed) {\r\n                grid.activeItem = oldVal;\r\n              } else {\r\n                grid.$connector.doDeselection([oldVal], true);\r\n              }\r\n            }\r\n          } else if (!selectedKeys[newVal.key]) {\r\n            grid.$connector.doSelection([newVal], true);\r\n          }\r\n        });\r\n        grid._createPropertyObserver('activeItem', '__activeItemChanged', true);\r\n\r\n        grid.__activeItemChangedDetails = tryCatchWrapper(function (newVal, oldVal) {\r\n          if (grid.__disallowDetailsOnClick) {\r\n            return;\r\n          }\r\n          // when grid is attached, newVal is not set and oldVal is undefined\r\n          // do nothing\r\n          if (newVal == null && oldVal === undefined) {\r\n            return;\r\n          }\r\n          if (newVal && !newVal.detailsOpened) {\r\n            grid.$server.setDetailsVisible(newVal.key);\r\n          } else {\r\n            grid.$server.setDetailsVisible(null);\r\n          }\r\n        });\r\n        grid._createPropertyObserver('activeItem', '__activeItemChangedDetails', true);\r\n\r\n        grid.$connector._getPageIfSameLevel = tryCatchWrapper(function (parentKey, index, defaultPage) {\r\n          let cacheAndIndex = grid._cache.getCacheAndIndex(index);\r\n          let parentItem = cacheAndIndex.cache.parentItem;\r\n          let parentKeyOfIndex = parentItem ? grid.getItemId(parentItem) : root;\r\n          if (parentKey !== parentKeyOfIndex) {\r\n            return defaultPage;\r\n          } else {\r\n            return grid._getPageForIndex(cacheAndIndex.scaledIndex);\r\n          }\r\n        });\r\n\r\n        grid.$connector.getCacheByKey = tryCatchWrapper(function (key) {\r\n          let cacheAndIndex = grid._cache.getCacheAndIndexByKey(key);\r\n          if (cacheAndIndex) {\r\n            return cacheAndIndex.cache;\r\n          }\r\n          return undefined;\r\n        });\r\n\r\n        grid.$connector.flushEnsureSubCache = tryCatchWrapper(function () {\r\n          let pendingFetch = ensureSubCacheQueue.splice(0, 1)[0];\r\n          let itemkey = pendingFetch.itemkey;\r\n\r\n          const visibleRows = grid._getVisibleRows();\r\n          let start = visibleRows[0].index;\r\n          let end = visibleRows[visibleRows.length - 1].index;\r\n\r\n          let buffer = end - start;\r\n          let firstNeededIndex = Math.max(0, start - buffer);\r\n          let lastNeededIndex = Math.min(end + buffer, grid._effectiveSize);\r\n\r\n          // only fetch if given item is still in visible range\r\n          for (let index = firstNeededIndex; index <= lastNeededIndex; index++) {\r\n            let item = grid._cache.getItemForIndex(index);\r\n\r\n            if (grid.getItemId(item) === itemkey) {\r\n              if (grid._isExpanded(item)) {\r\n                pendingFetch.cache.doEnsureSubCacheForScaledIndex(pendingFetch.scaledIndex);\r\n                return true;\r\n              } else {\r\n                break;\r\n              }\r\n            }\r\n          }\r\n          return false;\r\n        });\r\n\r\n        grid.$connector.flushParentRequests = tryCatchWrapper(function () {\r\n          let pendingFetches = parentRequestQueue.splice(0, parentRequestBatchMaxSize);\r\n\r\n          if (pendingFetches.length) {\r\n            grid.$server.setParentRequestedRanges(pendingFetches);\r\n            return true;\r\n          }\r\n          return false;\r\n        });\r\n\r\n        grid.$connector.beforeParentRequest = tryCatchWrapper(function (firstIndex, size, parentKey) {\r\n          // add request in queue\r\n          parentRequestQueue.push({\r\n            firstIndex: firstIndex,\r\n            size: size,\r\n            parentKey: parentKey\r\n          });\r\n\r\n          parentRequestDebouncer = Debouncer.debounce(parentRequestDebouncer, timeOut.after(parentRequestDelay), () => {\r\n            while (parentRequestQueue.length) {\r\n              grid.$connector.flushParentRequests();\r\n            }\r\n          });\r\n        });\r\n\r\n        grid.$connector.fetchPage = tryCatchWrapper(function (fetch, page, parentKey) {\r\n          // Determine what to fetch based on scroll position and not only\r\n          // what grid asked for\r\n\r\n          // The buffer size could be multiplied by some constant defined by the user,\r\n          // if he needs to reduce the number of items sent to the Grid to improve performance\r\n          // or to increase it to make Grid smoother when scrolling\r\n          const visibleRows = grid._getVisibleRows();\r\n          let start = visibleRows.length > 0 ? visibleRows[0].index : 0;\r\n          let end = visibleRows.length > 0 ? visibleRows[visibleRows.length - 1].index : 0;\r\n          let buffer = end - start;\r\n\r\n          let firstNeededIndex = Math.max(0, start - buffer);\r\n          let lastNeededIndex = Math.min(end + buffer, grid._effectiveSize);\r\n\r\n          let firstNeededPage = page;\r\n          let lastNeededPage = page;\r\n          for (let idx = firstNeededIndex; idx <= lastNeededIndex; idx++) {\r\n            firstNeededPage = Math.min(\r\n              firstNeededPage,\r\n              grid.$connector._getPageIfSameLevel(parentKey, idx, firstNeededPage)\r\n            );\r\n            lastNeededPage = Math.max(\r\n              lastNeededPage,\r\n              grid.$connector._getPageIfSameLevel(parentKey, idx, lastNeededPage)\r\n            );\r\n          }\r\n\r\n          let firstPage = Math.max(0, firstNeededPage);\r\n          let lastPage =\r\n            parentKey !== root ? lastNeededPage : Math.min(lastNeededPage, Math.floor(grid.size / grid.pageSize));\r\n          let lastRequestedRange = lastRequestedRanges[parentKey];\r\n          if (!lastRequestedRange) {\r\n            lastRequestedRange = [-1, -1];\r\n          }\r\n          if (lastRequestedRange[0] != firstPage || lastRequestedRange[1] != lastPage) {\r\n            lastRequestedRange = [firstPage, lastPage];\r\n            lastRequestedRanges[parentKey] = lastRequestedRange;\r\n            let count = lastPage - firstPage + 1;\r\n            fetch(firstPage * grid.pageSize, count * grid.pageSize);\r\n          }\r\n        });\r\n\r\n        grid.dataProvider = tryCatchWrapper(function (params, callback) {\r\n          if (params.pageSize != grid.pageSize) {\r\n            throw 'Invalid pageSize';\r\n          }\r\n\r\n          let page = params.page;\r\n\r\n          if (params.parentItem) {\r\n            let parentUniqueKey = grid.getItemId(params.parentItem);\r\n            if (!treePageCallbacks[parentUniqueKey]) {\r\n              treePageCallbacks[parentUniqueKey] = {};\r\n            }\r\n\r\n            let parentCache = grid.$connector.getCacheByKey(parentUniqueKey);\r\n            let itemCache =\r\n              parentCache && parentCache.itemkeyCaches ? parentCache.itemkeyCaches[parentUniqueKey] : undefined;\r\n            if (cache[parentUniqueKey] && cache[parentUniqueKey][page] && itemCache) {\r\n              // workaround: sometimes grid-element gives page index that overflows\r\n              page = Math.min(page, Math.floor(cache[parentUniqueKey].size / grid.pageSize));\r\n\r\n              // Ensure grid isn't in loading state when the callback executes\r\n              ensureSubCacheQueue = [];\r\n              callback(cache[parentUniqueKey][page], cache[parentUniqueKey].size);\r\n\r\n              // Flush after the callback to have the grid rows up-to-date\r\n              updateAllGridRowsInDomBasedOnCache();\r\n              // Prevent sub-caches from being created (& data requests sent) for items\r\n              // that may no longer be visible\r\n              ensureSubCacheQueue = [];\r\n              // Eliminate flickering on eager fetch mode\r\n              grid.requestContentUpdate();\r\n            } else {\r\n              treePageCallbacks[parentUniqueKey][page] = callback;\r\n\r\n              grid.$connector.fetchPage(\r\n                (firstIndex, size) => grid.$connector.beforeParentRequest(firstIndex, size, params.parentItem.key),\r\n                page,\r\n                parentUniqueKey\r\n              );\r\n            }\r\n          } else {\r\n            // workaround: sometimes grid-element gives page index that overflows\r\n            page = Math.min(page, Math.floor(grid.size / grid.pageSize));\r\n\r\n            if (cache[root] && cache[root][page]) {\r\n              callback(cache[root][page]);\r\n            } else {\r\n              rootPageCallbacks[page] = callback;\r\n\r\n              rootRequestDebouncer = Debouncer.debounce(\r\n                rootRequestDebouncer,\r\n                timeOut.after(grid._hasData ? rootRequestDelay : 0),\r\n                () => {\r\n                  grid.$connector.fetchPage(\r\n                    (firstIndex, size) => grid.$server.setRequestedRange(firstIndex, size),\r\n                    page,\r\n                    root\r\n                  );\r\n                }\r\n              );\r\n            }\r\n          }\r\n        });\r\n\r\n        const sorterChangeListener = tryCatchWrapper(function (_, oldValue) {\r\n          if (oldValue !== undefined && !sorterDirectionsSetFromServer) {\r\n            grid.$server.sortersChanged(\r\n              grid._sorters.map(function (sorter) {\r\n                return {\r\n                  path: sorter.path,\r\n                  direction: sorter.direction\r\n                };\r\n              })\r\n            );\r\n          }\r\n        });\r\n\r\n        grid.$connector.setSorterDirections = tryCatchWrapper(function (directions) {\r\n          sorterDirectionsSetFromServer = true;\r\n          setTimeout(\r\n            tryCatchWrapper(() => {\r\n              try {\r\n                const sorters = Array.from(grid.querySelectorAll('vaadin-grid-sorter'));\r\n\r\n                // Sorters for hidden columns are removed from DOM but stored in the web component.\r\n                // We need to ensure that all the sorters are reset when using `grid.sort(null)`.\r\n                grid._sorters.forEach((sorter) => {\r\n                  if (!sorters.includes(sorter)) {\r\n                    sorters.push(sorter);\r\n                  }\r\n                });\r\n\r\n                sorters.forEach((sorter) => {\r\n                  if (!directions.filter((d) => d.column === sorter.getAttribute('path'))[0]) {\r\n                    sorter.direction = null;\r\n                  }\r\n                });\r\n\r\n                // Apply directions in correct order, depending on configured multi-sort priority.\r\n                // For the default \"prepend\" mode, directions need to be applied in reverse, in\r\n                // order for the sort indicators to match the order on the server. For \"append\"\r\n                // just keep the order passed from the server.\r\n                if (grid.multiSortPriority !== 'append') {\r\n                  directions = directions.reverse()\r\n                }\r\n                directions.forEach(({ column, direction }) => {\r\n                  sorters.forEach((sorter) => {\r\n                    if (sorter.getAttribute('path') === column && sorter.direction !== direction) {\r\n                      sorter.direction = direction;\r\n                    }\r\n                  });\r\n                });\r\n              } finally {\r\n                sorterDirectionsSetFromServer = false;\r\n              }\r\n            })\r\n          );\r\n        });\r\n        grid._createPropertyObserver('_previousSorters', sorterChangeListener);\r\n\r\n        grid._updateItem = tryCatchWrapper(function (row, item) {\r\n          Grid.prototype._updateItem.call(grid, row, item);\r\n\r\n          // There might be inactive component renderers on hidden rows that still refer to the\r\n          // same component instance as one of the renderers on a visible row. Making the\r\n          // inactive/hidden renderer attach the component might steal it from a visible/active one.\r\n          if (!row.hidden) {\r\n            // make sure that component renderers are updated\r\n            Array.from(row.children).forEach((cell) => {\r\n              if (cell._content && cell._content.__templateInstance && cell._content.__templateInstance.children) {\r\n                Array.from(cell._content.__templateInstance.children).forEach((content) => {\r\n                  if (content._attachRenderedComponentIfAble) {\r\n                    content._attachRenderedComponentIfAble();\r\n                  }\r\n                  // In hierarchy column of tree grid, the component renderer is inside its content,\r\n                  // this updates it renderer from innerContent\r\n                  if (content.children) {\r\n                    Array.from(content.children).forEach((innerContent) => {\r\n                      if (innerContent._attachRenderedComponentIfAble) {\r\n                        innerContent._attachRenderedComponentIfAble();\r\n                      }\r\n                    });\r\n                  }\r\n                });\r\n              }\r\n            });\r\n          }\r\n          // since no row can be selected when selection mode is NONE\r\n          // if selectionMode is set to NONE, remove aria-selected attribute from the row\r\n          if (selectionMode === validSelectionModes[1]) {\r\n            // selectionMode === NONE\r\n            row.removeAttribute('aria-selected');\r\n            Array.from(row.children).forEach((cell) => cell.removeAttribute('aria-selected'));\r\n          }\r\n        });\r\n\r\n        const itemExpandedChanged = tryCatchWrapper(function (item, expanded) {\r\n          // method available only for the TreeGrid server-side component\r\n          if (item == undefined || grid.$server.updateExpandedState == undefined) {\r\n            return;\r\n          }\r\n          let parentKey = grid.getItemId(item);\r\n          grid.$server.updateExpandedState(parentKey, expanded);\r\n\r\n          if (!expanded) {\r\n            delete cache[parentKey];\r\n            let parentCache = grid.$connector.getCacheByKey(parentKey);\r\n            if (parentCache && parentCache.itemkeyCaches && parentCache.itemkeyCaches[parentKey]) {\r\n              delete parentCache.itemkeyCaches[parentKey];\r\n            }\r\n            if (parentCache && parentCache.itemkeyCaches) {\r\n              Object.keys(parentCache.itemCaches)\r\n                .filter((idx) => parentCache.items[idx].key === parentKey)\r\n                .forEach((idx) => delete parentCache.itemCaches[idx]);\r\n            }\r\n            delete lastRequestedRanges[parentKey];\r\n          }\r\n        });\r\n\r\n        // Patch grid.expandItem and grid.collapseItem to have\r\n        // itemExpandedChanged run when either happens.\r\n        grid.expandItem = tryCatchWrapper(function (item) {\r\n          itemExpandedChanged(item, true);\r\n          Grid.prototype.expandItem.call(grid, item);\r\n        });\r\n\r\n        grid.collapseItem = tryCatchWrapper(function (item) {\r\n          itemExpandedChanged(item, false);\r\n          Grid.prototype.collapseItem.call(grid, item);\r\n        });\r\n\r\n        const itemsUpdated = function (items) {\r\n          if (!items || !Array.isArray(items)) {\r\n            throw 'Attempted to call itemsUpdated with an invalid value: ' + JSON.stringify(items);\r\n          }\r\n          let detailsOpenedItems = Array.from(grid.detailsOpenedItems);\r\n          let updatedSelectedItem = false;\r\n          for (let i = 0; i < items.length; ++i) {\r\n            const item = items[i];\r\n            if (!item) {\r\n              continue;\r\n            }\r\n            if (item.detailsOpened) {\r\n              if (grid._getItemIndexInArray(item, detailsOpenedItems) < 0) {\r\n                detailsOpenedItems.push(item);\r\n              }\r\n            } else if (grid._getItemIndexInArray(item, detailsOpenedItems) >= 0) {\r\n              detailsOpenedItems.splice(grid._getItemIndexInArray(item, detailsOpenedItems), 1);\r\n            }\r\n            if (selectedKeys[item.key]) {\r\n              selectedKeys[item.key] = item;\r\n              item.selected = true;\r\n              updatedSelectedItem = true;\r\n            }\r\n          }\r\n          grid.detailsOpenedItems = detailsOpenedItems;\r\n          if (updatedSelectedItem) {\r\n            // IE 11 Object doesn't support method values\r\n            grid.selectedItems = Object.keys(selectedKeys).map(function (e) {\r\n              return selectedKeys[e];\r\n            });\r\n          }\r\n        };\r\n\r\n        /**\r\n         * Updates the cache for the given page for grid or tree-grid.\r\n         *\r\n         * @param page index of the page to update\r\n         * @param parentKey the key of the parent item for the page\r\n         * @returns an array of the updated items for the page, or undefined if no items were cached for the page\r\n         */\r\n        const updateGridCache = function (page, parentKey) {\r\n          let items;\r\n          if ((parentKey || root) !== root) {\r\n            items = cache[parentKey][page];\r\n            let parentCache = grid.$connector.getCacheByKey(parentKey);\r\n            if (parentCache && parentCache.itemkeyCaches) {\r\n              let _cache = parentCache.itemkeyCaches[parentKey];\r\n              const callbacksForParentKey = treePageCallbacks[parentKey];\r\n              const callback = callbacksForParentKey && callbacksForParentKey[page];\r\n              _updateGridCache(page, items, callback, _cache);\r\n            }\r\n          } else {\r\n            items = cache[root][page];\r\n            _updateGridCache(page, items, rootPageCallbacks[page], grid._cache);\r\n          }\r\n          return items;\r\n        };\r\n\r\n        const _updateGridCache = function (page, items, callback, levelcache) {\r\n          // Force update unless there's a callback waiting\r\n          if (!callback) {\r\n            let rangeStart = page * grid.pageSize;\r\n            let rangeEnd = rangeStart + grid.pageSize;\r\n            if (!items) {\r\n              if (levelcache && levelcache.items) {\r\n                for (let idx = rangeStart; idx < rangeEnd; idx++) {\r\n                  delete levelcache.items[idx];\r\n                }\r\n              }\r\n            } else {\r\n              if (levelcache && levelcache.items) {\r\n                for (let idx = rangeStart; idx < rangeEnd; idx++) {\r\n                  if (levelcache.items[idx]) {\r\n                    levelcache.items[idx] = items[idx - rangeStart];\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        };\r\n\r\n        /**\r\n         * Updates all visible grid rows in DOM.\r\n         */\r\n        const updateAllGridRowsInDomBasedOnCache = function () {\r\n          grid._cache.updateSize();\r\n          grid._effectiveSize = grid._cache.effectiveSize;\r\n          grid.__updateVisibleRows();\r\n        };\r\n\r\n        /**\r\n         * Update the given items in DOM if currently visible.\r\n         *\r\n         * @param array items the items to update in DOM\r\n         */\r\n        const updateGridItemsInDomBasedOnCache = function (items) {\r\n          if (!items || !grid.$ || grid.$.items.childElementCount === 0) {\r\n            return;\r\n          }\r\n\r\n          const itemKeys = items.map((item) => item.key);\r\n          const indexes = grid\r\n            ._getVisibleRows()\r\n            .filter((row) => row._item && itemKeys.includes(row._item.key))\r\n            .map((row) => row.index);\r\n          if (indexes.length > 0) {\r\n            grid.__updateVisibleRows(indexes[0], indexes[indexes.length - 1]);\r\n          }\r\n        };\r\n\r\n        grid.$connector.set = tryCatchWrapper(function (index, items, parentKey) {\r\n          if (index % grid.pageSize != 0) {\r\n            throw 'Got new data to index ' + index + ' which is not aligned with the page size of ' + grid.pageSize;\r\n          }\r\n          let pkey = parentKey || root;\r\n\r\n          const firstPage = index / grid.pageSize;\r\n          const updatedPageCount = Math.ceil(items.length / grid.pageSize);\r\n\r\n          for (let i = 0; i < updatedPageCount; i++) {\r\n            let page = firstPage + i;\r\n            let slice = items.slice(i * grid.pageSize, (i + 1) * grid.pageSize);\r\n            if (!cache[pkey]) {\r\n              cache[pkey] = {};\r\n            }\r\n            cache[pkey][page] = slice;\r\n\r\n            grid.$connector.doSelection(slice.filter((item) => item.selected));\r\n            grid.$connector.doDeselection(\r\n              slice.filter((item) => !item.selected && selectedKeys[item.key])\r\n            );\r\n\r\n            const updatedItems = updateGridCache(page, pkey);\r\n            if (updatedItems) {\r\n              itemsUpdated(updatedItems);\r\n              updateGridItemsInDomBasedOnCache(updatedItems);\r\n            }\r\n          }\r\n        });\r\n\r\n        const itemToCacheLocation = function (item) {\r\n          let parent = item.parentUniqueKey || root;\r\n          if (cache[parent]) {\r\n            for (let page in cache[parent]) {\r\n              for (let index in cache[parent][page]) {\r\n                if (grid.getItemId(cache[parent][page][index]) === grid.getItemId(item)) {\r\n                  return { page: page, index: index, parentKey: parent };\r\n                }\r\n              }\r\n            }\r\n          }\r\n          return null;\r\n        };\r\n\r\n        /**\r\n         * Updates the given items for a hierarchical grid.\r\n         *\r\n         * @param updatedItems the updated items array\r\n         */\r\n        grid.$connector.updateHierarchicalData = tryCatchWrapper(function (updatedItems) {\r\n          let pagesToUpdate = [];\r\n          // locate and update the items in cache\r\n          // find pages that need updating\r\n          for (let i = 0; i < updatedItems.length; i++) {\r\n            let cacheLocation = itemToCacheLocation(updatedItems[i]);\r\n            if (cacheLocation) {\r\n              cache[cacheLocation.parentKey][cacheLocation.page][cacheLocation.index] = updatedItems[i];\r\n              let key = cacheLocation.parentKey + ':' + cacheLocation.page;\r\n              if (!pagesToUpdate[key]) {\r\n                pagesToUpdate[key] = {\r\n                  parentKey: cacheLocation.parentKey,\r\n                  page: cacheLocation.page\r\n                };\r\n              }\r\n            }\r\n          }\r\n          // IE11 doesn't work with the transpiled version of the forEach.\r\n          let keys = Object.keys(pagesToUpdate);\r\n          for (let i = 0; i < keys.length; i++) {\r\n            let pageToUpdate = pagesToUpdate[keys[i]];\r\n            const affectedUpdatedItems = updateGridCache(pageToUpdate.page, pageToUpdate.parentKey);\r\n            if (affectedUpdatedItems) {\r\n              itemsUpdated(affectedUpdatedItems);\r\n              updateGridItemsInDomBasedOnCache(affectedUpdatedItems);\r\n            }\r\n          }\r\n        });\r\n\r\n        /**\r\n         * Updates the given items for a non-hierarchical grid.\r\n         *\r\n         * @param updatedItems the updated items array\r\n         */\r\n        grid.$connector.updateFlatData = tryCatchWrapper(function (updatedItems) {\r\n          // update (flat) caches\r\n          for (let i = 0; i < updatedItems.length; i++) {\r\n            let cacheLocation = itemToCacheLocation(updatedItems[i]);\r\n            if (cacheLocation) {\r\n              // update connector cache\r\n              cache[cacheLocation.parentKey][cacheLocation.page][cacheLocation.index] = updatedItems[i];\r\n\r\n              // update grid's cache\r\n              const index = parseInt(cacheLocation.page) * grid.pageSize + parseInt(cacheLocation.index);\r\n              if (grid._cache.items[index]) {\r\n                grid._cache.items[index] = updatedItems[i];\r\n              }\r\n            }\r\n          }\r\n          itemsUpdated(updatedItems);\r\n\r\n          updateGridItemsInDomBasedOnCache(updatedItems);\r\n        });\r\n\r\n        grid.$connector.clearExpanded = tryCatchWrapper(function () {\r\n          grid.expandedItems = [];\r\n          ensureSubCacheQueue = [];\r\n          parentRequestQueue = [];\r\n        });\r\n\r\n        grid.$connector.clear = tryCatchWrapper(function (index, length, parentKey) {\r\n          let pkey = parentKey || root;\r\n          if (!cache[pkey] || Object.keys(cache[pkey]).length === 0) {\r\n            return;\r\n          }\r\n          if (index % grid.pageSize != 0) {\r\n            throw (\r\n              'Got cleared data for index ' + index + ' which is not aligned with the page size of ' + grid.pageSize\r\n            );\r\n          }\r\n\r\n          let firstPage = Math.floor(index / grid.pageSize);\r\n          let updatedPageCount = Math.ceil(length / grid.pageSize);\r\n\r\n          for (let i = 0; i < updatedPageCount; i++) {\r\n            let page = firstPage + i;\r\n            let items = cache[pkey][page];\r\n            grid.$connector.doDeselection(items.filter((item) => selectedKeys[item.key]));\r\n            delete cache[pkey][page];\r\n            const updatedItems = updateGridCache(page, parentKey);\r\n            if (updatedItems) {\r\n              itemsUpdated(updatedItems);\r\n            }\r\n            updateGridItemsInDomBasedOnCache(items);\r\n          }\r\n          let cacheToClear = grid._cache;\r\n          if (parentKey) {\r\n            const cacheAndIndex = grid._cache.getCacheAndIndexByKey(pkey);\r\n            cacheToClear = cacheAndIndex.cache.itemCaches[cacheAndIndex.scaledIndex];\r\n          }\r\n          const endIndex = index + updatedPageCount * grid.pageSize;\r\n          for (let itemIndex = index; itemIndex < endIndex; itemIndex++) {\r\n            delete cacheToClear.items[itemIndex];\r\n            const subcacheToClear = cacheToClear.itemCaches[itemIndex];\r\n            delete cacheToClear.itemCaches[itemIndex];\r\n            const itemKeyToRemove = subcacheToClear && subcacheToClear.parentItem.key;\r\n            if (itemKeyToRemove) {\r\n              delete cacheToClear.itemkeyCaches[itemKeyToRemove];\r\n            }\r\n          }\r\n          grid._cache.updateSize();\r\n        });\r\n\r\n        grid.$connector.reset = tryCatchWrapper(function () {\r\n          grid.size = 0;\r\n          deleteObjectContents(cache);\r\n          deleteObjectContents(grid._cache.items);\r\n          deleteObjectContents(lastRequestedRanges);\r\n          if (ensureSubCacheDebouncer) {\r\n            ensureSubCacheDebouncer.cancel();\r\n          }\r\n          if (parentRequestDebouncer) {\r\n            parentRequestDebouncer.cancel();\r\n          }\r\n          if (rootRequestDebouncer) {\r\n            rootRequestDebouncer.cancel();\r\n          }\r\n          ensureSubCacheDebouncer = undefined;\r\n          parentRequestDebouncer = undefined;\r\n          ensureSubCacheQueue = [];\r\n          parentRequestQueue = [];\r\n          updateAllGridRowsInDomBasedOnCache();\r\n        });\r\n\r\n        const deleteObjectContents = (obj) => Object.keys(obj).forEach((key) => delete obj[key]);\r\n\r\n        grid.$connector.updateSize = (newSize) => (grid.size = newSize);\r\n\r\n        grid.$connector.updateUniqueItemIdPath = (path) => (grid.itemIdPath = path);\r\n\r\n        grid.$connector.expandItems = tryCatchWrapper(function (items) {\r\n          let newExpandedItems = Array.from(grid.expandedItems);\r\n          items.filter((item) => !grid._isExpanded(item)).forEach((item) => newExpandedItems.push(item));\r\n          grid.expandedItems = newExpandedItems;\r\n        });\r\n\r\n        grid.$connector.collapseItems = tryCatchWrapper(function (items) {\r\n          let newExpandedItems = Array.from(grid.expandedItems);\r\n          items.forEach((item) => {\r\n            let index = grid._getItemIndexInArray(item, newExpandedItems);\r\n            if (index >= 0) {\r\n              newExpandedItems.splice(index, 1);\r\n            }\r\n          });\r\n          grid.expandedItems = newExpandedItems;\r\n          items.forEach((item) => grid.$connector.removeFromQueue(item));\r\n        });\r\n\r\n        grid.$connector.removeFromQueue = tryCatchWrapper(function (item) {\r\n          let itemId = grid.getItemId(item);\r\n          delete treePageCallbacks[itemId];\r\n          grid.$connector.removeFromArray(ensureSubCacheQueue, (item) => item.itemkey === itemId);\r\n          grid.$connector.removeFromArray(parentRequestQueue, (item) => item.parentKey === itemId);\r\n        });\r\n\r\n        grid.$connector.removeFromArray = tryCatchWrapper(function (array, removeTest) {\r\n          if (array.length) {\r\n            for (let index = array.length - 1; index--; ) {\r\n              if (removeTest(array[index])) {\r\n                array.splice(index, 1);\r\n              }\r\n            }\r\n          }\r\n        });\r\n\r\n        grid.$connector.confirmParent = tryCatchWrapper(function (id, parentKey, levelSize) {\r\n          if (!cache[parentKey]) {\r\n            cache[parentKey] = {};\r\n          }\r\n          cache[parentKey].size = levelSize;\r\n          if (levelSize === 0) {\r\n            cache[parentKey][0] = [];\r\n          }\r\n\r\n          let outstandingRequests = Object.getOwnPropertyNames(treePageCallbacks[parentKey] || {});\r\n          for (let i = 0; i < outstandingRequests.length; i++) {\r\n            let page = outstandingRequests[i];\r\n\r\n            let lastRequestedRange = lastRequestedRanges[parentKey] || [0, 0];\r\n\r\n            const callback = treePageCallbacks[parentKey][page];\r\n            if (\r\n              (cache[parentKey] && cache[parentKey][page]) ||\r\n              page < lastRequestedRange[0] ||\r\n              page > lastRequestedRange[1]\r\n            ) {\r\n              delete treePageCallbacks[parentKey][page];\r\n              let items = cache[parentKey][page] || new Array(levelSize);\r\n              callback(items, levelSize);\r\n            } else if (callback && levelSize === 0) {\r\n              // The parent item has 0 child items => resolve the callback with an empty array\r\n              delete treePageCallbacks[parentKey][page];\r\n              callback([], levelSize);\r\n            }\r\n          }\r\n          // Let server know we're done\r\n          grid.$server.confirmParentUpdate(id, parentKey);\r\n\r\n          if (!grid.loading) {\r\n            grid.__updateVisibleRows();\r\n          }\r\n        });\r\n\r\n        grid.$connector.confirm = tryCatchWrapper(function (id) {\r\n          // We're done applying changes from this batch, resolve outstanding\r\n          // callbacks\r\n          let outstandingRequests = Object.getOwnPropertyNames(rootPageCallbacks);\r\n          for (let i = 0; i < outstandingRequests.length; i++) {\r\n            let page = outstandingRequests[i];\r\n            let lastRequestedRange = lastRequestedRanges[root] || [0, 0];\r\n\r\n            const lastAvailablePage = grid.size ? Math.ceil(grid.size / grid.pageSize) - 1 : 0;\r\n            // It's possible that the lastRequestedRange includes a page that's beyond lastAvailablePage if the grid's size got reduced during an ongoing data request\r\n            const lastRequestedRangeEnd = Math.min(lastRequestedRange[1], lastAvailablePage);\r\n            // Resolve if we have data or if we don't expect to get data\r\n            const callback = rootPageCallbacks[page];\r\n            if ((cache[root] && cache[root][page]) || page < lastRequestedRange[0] || +page > lastRequestedRangeEnd) {\r\n              delete rootPageCallbacks[page];\r\n\r\n              if (cache[root][page]) {\r\n                // Cached data is available, resolve the callback\r\n                callback(cache[root][page]);\r\n              } else {\r\n                // No cached data, resolve the callback with an empty array\r\n                callback(new Array(grid.pageSize));\r\n                // Request grid for content update\r\n                grid.requestContentUpdate();\r\n              }\r\n\r\n              // Makes sure to push all new rows before this stack execution is done so any timeout expiration called after will be applied on a fully updated grid\r\n              //Resolves https://github.com/vaadin/vaadin-grid-flow/issues/511\r\n              if (grid._debounceIncreasePool) {\r\n                grid._debounceIncreasePool.flush();\r\n              }\r\n            } else if (callback && grid.size === 0) {\r\n              // The grid has 0 items => resolve the callback with an empty array\r\n              delete rootPageCallbacks[page];\r\n              callback([]);\r\n            }\r\n          }\r\n\r\n          // Let server know we're done\r\n          grid.$server.confirmUpdate(id);\r\n        });\r\n\r\n        grid.$connector.ensureHierarchy = tryCatchWrapper(function () {\r\n          for (let parentKey in cache) {\r\n            if (parentKey !== root) {\r\n              delete cache[parentKey];\r\n            }\r\n          }\r\n          deleteObjectContents(lastRequestedRanges);\r\n\r\n          grid._cache.itemCaches = {};\r\n          grid._cache.itemkeyCaches = {};\r\n\r\n          updateAllGridRowsInDomBasedOnCache();\r\n        });\r\n\r\n        grid.$connector.setSelectionMode = tryCatchWrapper(function (mode) {\r\n          if ((typeof mode === 'string' || mode instanceof String) && validSelectionModes.indexOf(mode) >= 0) {\r\n            selectionMode = mode;\r\n            selectedKeys = {};\r\n            grid.$connector.updateMultiSelectable();\r\n          } else {\r\n            throw 'Attempted to set an invalid selection mode';\r\n          }\r\n        });\r\n\r\n        /*\r\n         * Manage aria-multiselectable attribute depending on the selection mode.\r\n         * see more: https://github.com/vaadin/web-components/issues/1536\r\n         * or: https://www.w3.org/TR/wai-aria-1.1/#aria-multiselectable\r\n         * For selection mode SINGLE, set the aria-multiselectable attribute to false\r\n         */\r\n        grid.$connector.updateMultiSelectable = tryCatchWrapper(function () {\r\n          if (!grid.$) {\r\n            return;\r\n          }\r\n\r\n          if (selectionMode === validSelectionModes[0]) {\r\n            grid.$.table.setAttribute('aria-multiselectable', false);\r\n            // For selection mode NONE, remove the aria-multiselectable attribute\r\n          } else if (selectionMode === validSelectionModes[1]) {\r\n            grid.$.table.removeAttribute('aria-multiselectable');\r\n            // For selection mode MULTI, set aria-multiselectable to true\r\n          } else {\r\n            grid.$.table.setAttribute('aria-multiselectable', true);\r\n          }\r\n        });\r\n\r\n        // Have the multi-selectable state updated on attach\r\n        grid._createPropertyObserver('isAttached', () => grid.$connector.updateMultiSelectable());\r\n\r\n        // TODO: should be removed once https://github.com/vaadin/vaadin-grid/issues/1471 gets implemented\r\n        grid.$connector.setVerticalScrollingEnabled = tryCatchWrapper(function (enabled) {\r\n          // There are two scollable containers in grid so apply the changes for both\r\n          setVerticalScrollingEnabled(grid.$.table, enabled);\r\n        });\r\n\r\n        const setVerticalScrollingEnabled = function (scrollable, enabled) {\r\n          // Prevent Y axis scrolling with CSS. This will hide the vertical scrollbar.\r\n          scrollable.style.overflowY = enabled ? '' : 'hidden';\r\n          // Clean up an existing listener\r\n          scrollable.removeEventListener('wheel', scrollable.__wheelListener);\r\n          // Add a wheel event listener with the horizontal scrolling prevention logic\r\n          !enabled &&\r\n            scrollable.addEventListener(\r\n              'wheel',\r\n              (scrollable.__wheelListener = tryCatchWrapper((e) => {\r\n                if (e.deltaX) {\r\n                  // If there was some horizontal delta related to the wheel event, force the vertical\r\n                  // delta to 0 and let grid process the wheel event normally\r\n                  Object.defineProperty(e, 'deltaY', { value: 0 });\r\n                } else {\r\n                  // If there was verical delta only, skip the grid's wheel event processing to\r\n                  // enable scrolling the page even if grid isn't scrolled to end\r\n                  e.stopImmediatePropagation();\r\n                }\r\n              }))\r\n            );\r\n        };\r\n\r\n        grid.addEventListener(\r\n          'vaadin-context-menu-before-open',\r\n          tryCatchWrapper(function (e) {\r\n            const { key, columnId } = e.detail;\r\n            grid.$server.updateContextMenuTargetItem(key, columnId);\r\n          })\r\n        );\r\n\r\n        grid.getContextMenuBeforeOpenDetail = tryCatchWrapper(function (event) {\r\n          // For `contextmenu` events, we need to access the source event,\r\n          // when using open on click we just use the click event itself\r\n          const sourceEvent = event.detail.sourceEvent || event;\r\n          const eventContext = grid.getEventContext(sourceEvent);\r\n          const key = (eventContext.item && eventContext.item.key) || '';\r\n          const columnId = (eventContext.column && eventContext.column.id) || '';\r\n          return { key, columnId };\r\n        });\r\n\r\n        grid.addEventListener(\r\n          'click',\r\n          tryCatchWrapper((e) => _fireClickEvent(e, 'item-click'))\r\n        );\r\n        grid.addEventListener(\r\n          'dblclick',\r\n          tryCatchWrapper((e) => _fireClickEvent(e, 'item-double-click'))\r\n        );\r\n\r\n        grid.addEventListener(\r\n          'column-resize',\r\n          tryCatchWrapper((e) => {\r\n            const cols = grid._getColumnsInOrder().filter((col) => !col.hidden);\r\n\r\n            cols.forEach((col) => {\r\n              col.dispatchEvent(new CustomEvent('column-drag-resize'));\r\n            });\r\n\r\n            grid.dispatchEvent(\r\n              new CustomEvent('column-drag-resize', {\r\n                detail: {\r\n                  resizedColumnKey: e.detail.resizedColumn._flowId\r\n                }\r\n              })\r\n            );\r\n          })\r\n        );\r\n\r\n        grid.addEventListener(\r\n          'column-reorder',\r\n          tryCatchWrapper((e) => {\r\n            const columns = grid._columnTree\r\n              .slice(0)\r\n              .pop()\r\n              .filter((c) => c._flowId)\r\n              .sort((b, a) => b._order - a._order)\r\n              .map((c) => c._flowId);\r\n\r\n            grid.dispatchEvent(\r\n              new CustomEvent('column-reorder-all-columns', {\r\n                detail: { columns }\r\n              })\r\n            );\r\n          })\r\n        );\r\n\r\n        grid.addEventListener(\r\n          'cell-focus',\r\n          tryCatchWrapper((e) => {\r\n            const eventContext = grid.getEventContext(e);\r\n            const expectedSectionValues = ['header', 'body', 'footer'];\r\n\r\n            if (expectedSectionValues.indexOf(eventContext.section) === -1) {\r\n              return;\r\n            }\r\n\r\n            grid.dispatchEvent(\r\n              new CustomEvent('grid-cell-focus', {\r\n                detail: {\r\n                  itemKey: eventContext.item ? eventContext.item.key : null,\r\n\r\n                  internalColumnId: eventContext.column ? eventContext.column._flowId : null,\r\n\r\n                  section: eventContext.section\r\n                }\r\n              })\r\n            );\r\n          })\r\n        );\r\n\r\n        function _fireClickEvent(event, eventName) {\r\n          // Click event was handled by the component inside grid, do nothing.\r\n          if (event.defaultPrevented) {\r\n            return;\r\n          }\r\n\r\n          const target = event.target;\r\n          const eventContext = grid.getEventContext(event);\r\n          const section = eventContext.section;\r\n\r\n          if (eventContext.item && !isFocusable(target) && section !== 'details') {\r\n            event.itemKey = eventContext.item.key;\r\n            // if you have a details-renderer, getEventContext().column is undefined\r\n            if (eventContext.column) {\r\n              event.internalColumnId = eventContext.column._flowId;\r\n            }\r\n            grid.dispatchEvent(new CustomEvent(eventName, { detail: event }));\r\n          }\r\n        }\r\n\r\n        grid.cellClassNameGenerator = tryCatchWrapper(function (column, rowData) {\r\n          const style = rowData.item.style;\r\n          if (!style) {\r\n            return;\r\n          }\r\n          return (style.row || '') + ' ' + ((column && style[column._flowId]) || '');\r\n        });\r\n\r\n        grid.dropFilter = tryCatchWrapper((rowData) => !rowData.item.dropDisabled);\r\n\r\n        grid.dragFilter = tryCatchWrapper((rowData) => !rowData.item.dragDisabled);\r\n\r\n        grid.addEventListener(\r\n          'grid-dragstart',\r\n          tryCatchWrapper((e) => {\r\n            if (grid._isSelected(e.detail.draggedItems[0])) {\r\n              // Dragging selected (possibly multiple) items\r\n              if (grid.__selectionDragData) {\r\n                Object.keys(grid.__selectionDragData).forEach((type) => {\r\n                  e.detail.setDragData(type, grid.__selectionDragData[type]);\r\n                });\r\n              } else {\r\n                (grid.__dragDataTypes || []).forEach((type) => {\r\n                  e.detail.setDragData(type, e.detail.draggedItems.map((item) => item.dragData[type]).join('\\n'));\r\n                });\r\n              }\r\n\r\n              if (grid.__selectionDraggedItemsCount > 1) {\r\n                e.detail.setDraggedItemsCount(grid.__selectionDraggedItemsCount);\r\n              }\r\n            } else {\r\n              // Dragging just one (non-selected) item\r\n              (grid.__dragDataTypes || []).forEach((type) => {\r\n                e.detail.setDragData(type, e.detail.draggedItems[0].dragData[type]);\r\n              });\r\n            }\r\n          })\r\n        );\r\n      })(grid)\r\n  };\r\n})();\r\n"],
  "mappings": "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",
  "names": ["grid", "cache", "item"]
}
