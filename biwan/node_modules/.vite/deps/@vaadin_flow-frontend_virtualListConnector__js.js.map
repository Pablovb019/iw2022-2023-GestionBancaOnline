{
  "version": 3,
  "sources": ["../../@vaadin/flow-frontend/virtualListConnector.js"],
  "sourcesContent": ["import { Debouncer } from '@polymer/polymer/lib/utils/debounce.js';\r\nimport { timeOut } from '@polymer/polymer/lib/utils/async.js';\r\n\r\nwindow.Vaadin.Flow.virtualListConnector = {\r\n  initLazy: function (list) {\r\n    // Check whether the connector was already initialized for the virtual list\r\n    if (list.$connector) {\r\n      return;\r\n    }\r\n\r\n    const extraItemsBuffer = 20;\r\n\r\n    let lastRequestedRange = [0, 0];\r\n\r\n    list.$connector = {};\r\n    list.$connector.placeholderItem = { __placeholder: true };\r\n\r\n    const updateRequestedItem = function () {\r\n      /*\r\n       * TODO virtual list seems to do a small index adjustment after scrolling\r\n       * has stopped. This causes a redundant request to be sent to make a\r\n       * corresponding minimal change to the buffer. We should avoid these\r\n       * requests by making the logic skip doing a request if the available\r\n       * buffer is within some tolerance compared to the requested buffer.\r\n       */\r\n      const visibleIndexes = [...list.children]\r\n        .filter((el) => '__virtualListIndex' in el)\r\n        .map((el) => el.__virtualListIndex);\r\n      const firstNeededItem = Math.min(...visibleIndexes);\r\n      const lastNeededItem = Math.max(...visibleIndexes);\r\n\r\n      let first = Math.max(0, firstNeededItem - extraItemsBuffer);\r\n      let last = Math.min(lastNeededItem + extraItemsBuffer, list.items.length);\r\n\r\n      if (lastRequestedRange[0] != first || lastRequestedRange[1] != last) {\r\n        lastRequestedRange = [first, last];\r\n        const count = 1 + last - first;\r\n        list.$server.setRequestedRange(first, count);\r\n      }\r\n    };\r\n\r\n    const scheduleUpdateRequest = function () {\r\n      list.__requestDebounce = Debouncer.debounce(list.__requestDebounce, timeOut.after(50), updateRequestedItem);\r\n    };\r\n\r\n    requestAnimationFrame(() => updateRequestedItem);\r\n\r\n    // Add an observer function that will invoke on virtualList.renderer property\r\n    // change and then patches it with a wrapper renderer\r\n    list.patchVirtualListRenderer = function () {\r\n      if (!list.renderer || list.renderer.__virtualListConnectorPatched) {\r\n        // The list either doesn't have a renderer yet or it's already been patched\r\n        return;\r\n      }\r\n\r\n      const originalRenderer = list.renderer;\r\n\r\n      const renderer = (root, list, model) => {\r\n        root.__virtualListIndex = model.index;\r\n\r\n        if (model.item === undefined) {\r\n          originalRenderer.call(list, root, list, {\r\n            ...model,\r\n            item: list.$connector.placeholderItem\r\n          });\r\n        } else {\r\n          originalRenderer.call(list, root, list, model);\r\n        }\r\n\r\n        /*\r\n         * Check if we need to do anything once things have settled down.\r\n         * This method is called multiple times in sequence for the same user\r\n         * action, but we only want to do the check once.\r\n         */\r\n        scheduleUpdateRequest();\r\n      };\r\n      renderer.__virtualListConnectorPatched = true;\r\n      renderer.__rendererId = originalRenderer.__rendererId;\r\n\r\n      list.renderer = renderer;\r\n    };\r\n\r\n    list._createPropertyObserver('renderer', 'patchVirtualListRenderer', true);\r\n    list.patchVirtualListRenderer();\r\n\r\n    list.items = [];\r\n\r\n    list.$connector.set = function (index, items) {\r\n      list.items.splice(index, items.length, ...items);\r\n      list.items = [...list.items];\r\n    };\r\n\r\n    list.$connector.clear = function (index, length) {\r\n      // How many items, starting from \"index\", should be set as undefined\r\n      const clearCount = Math.min(length, list.items.length - index);\r\n      list.$connector.set(index, [...Array(clearCount)]);\r\n    };\r\n\r\n    list.$connector.updateData = function (items) {\r\n      const updatedItemsMap = items.reduce((map, item) => {\r\n        map[item.key] = item;\r\n        return map;\r\n      }, {});\r\n\r\n      list.items = list.items.map((item) => {\r\n        // Items can be undefined if they are outside the viewport\r\n        if (!item) {\r\n          return item;\r\n        }\r\n        // Replace existing item with updated item,\r\n        // return existing item as fallback if it was not updated\r\n        return updatedItemsMap[item.key] || item;\r\n      });\r\n    };\r\n\r\n    list.$connector.updateSize = function (newSize) {\r\n      const delta = newSize - list.items.length;\r\n      if (delta > 0) {\r\n        list.items = [...list.items, ...Array(delta)];\r\n      } else if (delta < 0) {\r\n        list.items = list.items.slice(0, newSize);\r\n      }\r\n    };\r\n\r\n    list.$connector.setPlaceholderItem = function (placeholderItem = {}) {\r\n      placeholderItem.__placeholder = true;\r\n      list.$connector.placeholderItem = placeholderItem;\r\n    };\r\n  }\r\n};\r\n"],
  "mappings": "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",
  "names": ["list"]
}
